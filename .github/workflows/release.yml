# This workflow builds release assets for amd64 and arm64 architectures in parallel.
name: "Build release"

on:
  workflow_dispatch

jobs:
  # The 'build' job now uses a matrix strategy to run for each specified architecture.
  build:
    name: Build for ${{ matrix.arch }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false # Ensures all matrix jobs complete, even if one fails.
      matrix:
        # Using 'arm64' as it's the standard identifier in GitHub Actions for aarch64
        arch: [amd64, arm64]
    
    # We define 'version' as an output to be used by the 'release' job.
    outputs:
      version: ${{ steps.get_version.outputs.version }}

    env:
      # This env var was in the original workflow.
      ACTIONS_ALLOW_UNSECURE_COMMANDS: true

    steps:
      - name: Check out code
        uses: actions/checkout@v4

      # QEMU is set up to allow building for arm64 on an amd64 runner through emulation.
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Get version from git tag
        id: get_version
        run: echo "version=$(git describe --tags --always --match 'app/v*' | sed -n 's|app/\([^/-]*\)\(-.*\)\{0,1\}|\1|p')" >> $GITHUB_OUTPUT

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.23"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Setup Android NDK
        uses: nttld/setup-ndk@v1
        id: setup-ndk
        with:
          ndk-version: r26b
          add-to-path: false

      - name: Run build script
        env:
          ANDROID_NDK_HOME: ${{ steps.setup-ndk.outputs.ndk-path }}
          # Set the target architecture. We assume the Python build script respects this.
          GOARCH: ${{ matrix.arch }}
        run: |
          export HY_APP_PLATFORMS=$(sed 's/\r$//' platforms.txt | awk '!/^#/ && !/^$/' | paste -sd ",")
          python hyperbole.py build -r

      - name: Package artifacts
        # This step renames build outputs to be arch-specific and generates hashes.
        run: |
          mkdir -p packaged-artifacts
          for file in build/*; do
            filename=$(basename "$file")
            # Add architecture suffix to the filename (e.g., myapp -> myapp-amd64)
            if [[ "$filename" == *.* ]]; then
              new_filename="${filename%.*}-${{ matrix.arch }}.${filename##*.}"
            else
              new_filename="${filename}-${{ matrix.arch }}"
            fi
            
            mv "$file" "packaged-artifacts/$new_filename"
            
            # Generate hash for the renamed file
            (cd packaged-artifacts && sha256sum "$new_filename" >> hashes-${{ matrix.arch }}.txt)
          done

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ matrix.arch }}
          path: packaged-artifacts/

  # The 'release' job runs after all 'build' jobs are successful.
  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: build # Depends on the successful completion of the 'build' job matrix.
    permissions:
      contents: write # Required to create a release.

    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          # Move all downloaded files from their subdirectories into one place.
          find artifacts/ -type f -exec mv {} release-assets/ \;
          # Combine all architecture-specific hash files into a single hashes.txt.
          cat release-assets/hashes-*.txt > release-assets/hashes.txt
          rm release-assets/hashes-*.txt

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          # The release tag is constructed using the version output from the build job.
          tag_name: app/v${{ needs.build.outputs.version }}
          files: release-assets/*
